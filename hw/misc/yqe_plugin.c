// This file implements MMIO communications with the YQE.
// Read waveform parameters from the executable, and send them to the
// backend simulator when the "trigger" command is received

#include "qemu/osdep.h"
#include "qapi/error.h" // provide error_fatal() handler
#include "hw/sysbus.h" // provides all sysbus registering func
#include "hw/misc/yqe_plugin.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TYPE_YQE_PLUGIN "yqe_plugin"
typedef struct YQEPluginState YQEPluginState;
DECLARE_INSTANCE_CHECKER(YQEPluginState, YQE_PLUGIN, TYPE_YQE_PLUGIN)

#define STORAGE_SIZE 0x100000
#define MAX_INST  0x400000
#define MAX_ENV_LEN 0x400
#define COMMAND_SIZE 200

static const int ADDR_TRIGGER = 0x1000, ADDR_WAIT = 0x2000,
                    ADDR_FMR_READY = 0x2FFF, ADDR_FMR = 0x3000,
                    ADDR_FMR_IQ = 0x4000, ADDR_PLAY = 0x8000,
                    ADDR_PARAMS = 0x10000, ADDR_ENVELOPE = 0x2400;
static const int ADDR_TRIGGER_INTERVAL = ADDR_TRIGGER + sizeof(int),
                     ADDR_TRIGGER_BITMASK = ADDR_TRIGGER + sizeof(int) * 2,
                     ADDR_OFFSET = ADDR_WAIT + sizeof(int),
                     ADDR_WAVE_LEN = ADDR_ENVELOPE - 2 * sizeof(int),
                     ADDR_WAVE_CHANNEL = ADDR_ENVELOPE - sizeof(int),
                     ADDR_WAVE_INDEX = ADDR_ENVELOPE - sizeof(uint16_t);

// struct for a quantum instruction
typedef struct {
  int time;
  int channel;
  uint8_t waveform;
  int res_addr;
  int res_addr_iq;
  double params[4];
} inst_s;

// internal state of the plugin
struct YQEPluginState {
  SysBusDevice parent_obj;
  MemoryRegion iomem;

  // command line instruction for the pulse simulator
  char command[COMMAND_SIZE];

  uint8_t storage[STORAGE_SIZE];
  int abs_time;  // time counter
  inst_s inst_queue[MAX_INST];
  int n_inst;
  FILE* proc;  // the subprocess for the backend simulator
  int repeat_count, n_meas, meas_addr[MAX_INST];
  int meas_addr_iq[MAX_INST];
};

// add instruction to the queue
static bool add_inst(YQEPluginState *s, int time, int channel,
              uint8_t waveform, int res_addr,
              int res_addr_iq, double* params) {
  if (s->n_inst >= MAX_INST) {
    fprintf(stderr,
        "Instruction (%d, %d, %d, %d) ignored because the instruction queue "
        "is "
        "full (max %d instructions)\n",
        time, channel, waveform, res_addr, MAX_INST);
    return false;
  }
  s->inst_queue[s->n_inst].time = time;
  s->inst_queue[s->n_inst].channel = channel;
  s->inst_queue[s->n_inst].waveform = waveform;
  s->inst_queue[s->n_inst].res_addr = res_addr;
  s->inst_queue[s->n_inst].res_addr_iq = res_addr_iq;
  for (int i = 0; i < 4; i++)
    s->inst_queue[s->n_inst].params[i] = params ? params[i] : 0.0;
  s->n_inst++;
  return true;
}

// read the output from pulse simulator. 
// wait the simulator to end if wait == true, otherwise just quit if not ready
static void check_results(YQEPluginState *s, bool wait) {
  if (!s->proc) return;
  if (wait) pclose(s->proc);
  FILE* fin = fopen("exit_code.txt", "r");
  if (!fin) {
    s->storage[ADDR_FMR_READY] = 0;
    return;
  }
  if (!wait) pclose(s->proc);  // make sure the exit code is actually written
  s->proc = NULL;
  int exit_code;
  int x = fscanf(fin, "%d", &exit_code);
  if (x == EOF)
    fprintf(stderr, "Cannot read exit code\n");
  fclose(fin);
  if (exit_code) {
    fprintf(stderr,
        "The pulse simulator backend has encountered an exception, "
        "exit code = %d\n",
        exit_code);
    exit(exit_code);
  }
  s->storage[ADDR_FMR_READY] = 1;
  // initialize the measurement result
  for (int i = 0; i < s->n_meas; i++) {
    *(int*)(s->storage + s->meas_addr[i]) = 0;
    *(double*)(s->storage + s->meas_addr_iq[i]) = 0;
    *(double*)(s->storage + s->meas_addr_iq[i] + sizeof(double)) =
        0;
  }
  // read the output file generated by the pulse simulator
  fin = fopen("output.txt", "r");
  for (int j = 0; j < s->repeat_count; j++)
    for (int i = 0; i < s->n_meas; i++) {
      char c;
      int x = fscanf(fin, " %c", &c);
      if (x == EOF)
        fprintf(stderr, "Cannot read output.txt\n");
      if (c == '1') (*(int*)(s->storage + s->meas_addr[i]))++;
    }
  for (int j = 0; j < s->repeat_count; j++) {
    for (int i = 0; i < s->n_meas; i++) {
      double c;
      int x = fscanf(fin, " %lf", &c);
      if (x == EOF)
        fprintf(stderr, "Cannot read output.txt\n");
      *(double*)(s->storage + s->meas_addr_iq[i]) += c;
      x = fscanf(fin, " %lf", &c);
      if (x == EOF)
        fprintf(stderr, "Cannot read output.txt\n");
      *(double*)(s->storage + s->meas_addr_iq[i] +
                                  sizeof(double)) += c;
    }
  }
  for (int i = 0; i < s->n_meas; i++) {
    *(double*)(s->storage + s->meas_addr_iq[i]) /= s->repeat_count;
    *(double*)(s->storage + s->meas_addr_iq[i] + sizeof(double)) /=
        s->repeat_count;
  }
  fclose(fin);
}

static bool store_envelope(YQEPluginState *s, uint16_t channel,
                            uint8_t index, int len) {
  // C++ does not have native supprt for json classes,
  // so we use python subprocess to temparorily manage json files
  if (len > MAX_ENV_LEN) {
    fprintf(stderr,
        "Envelope length %d exceeds maximum envelope length allowed. "
        "Truncating to %d\n",
        len, MAX_ENV_LEN);
    len = MAX_ENV_LEN;
  }
  // print the envelope data into a file
  FILE* fout = fopen("envelope.txt", "w");
  fprintf(fout, "%d %d %d\n", channel, index, len);
  for (int i = 0; i < len; i++) {
    fprintf(fout, "%hu\n",
            *(uint16_t*)(s->storage + ADDR_ENVELOPE +
                                          i * sizeof(uint16_t)));
  }
  fclose(fout);
  int i = system(
      "python3 /yaqcs-arch/simulator/pulse_simulator/envelope_transmission.py "
      "envelope.txt /yaqcs-arch/simulator/pulse_simulator/pulse.json");
  if (i != 0) {
    fprintf(stderr, "Pulse transmission encountered a problem\n");
    exit(i);
  }
  i = system("rm -f envelope.txt");
  if (i != 0)
    fprintf(stderr, "Cannot remove envelope.txt\n");
  fprintf(stderr,
      "Envelope with length %d successfully transmitted to channel %d index "
      "%d\n",
      len, channel, index);
  return true;
}

// RISC-V executable reading data from YQE via MMIO
static uint64_t yqe_plugin_read(void *opaque, hwaddr addr, unsigned int size) {
  YQEPluginState *s = opaque;

  if (addr + size > STORAGE_SIZE) {
    fprintf(stderr, "Load address 0x%x and length %lu out of bound\n",
            (unsigned int)addr, (long) size);
    return 0;
  }
  check_results(s, false);
  uint64_t result;
  switch (size) {
    case 1:
      result = s->storage[addr];
      break;
    case 2:
      result = *((uint16_t *) (s->storage + addr));
      break;
    case 4:
      result = *((uint32_t *) (s->storage + addr));
      break;
    case 8:
      *((double*) &result) = *((double *) (s->storage + addr));
      break;

    default:
      fprintf(stderr, "Unsupported length of loading %lu\n", (long) size);
      return 0;
  }

  // print the result to stderr
  if (addr != ADDR_FMR_READY) {
    fprintf(stderr, "Fetch results from 0x%x\n",
             (unsigned int)(0x40000000 + addr));
    if (size != 8) {
    fprintf(stderr, "The result is %lld\n", (long long) result);
    } else {
      fprintf(stderr, "The result is %lf\n", result);
    }
  }
  return result;
}

// RISC-V executable writing data to YQE via MMIO
static void yqe_plugin_write(void *opaque, hwaddr addr, uint64_t data,
                               unsigned int size) {
  YQEPluginState *s = opaque;

  if (addr + size > STORAGE_SIZE) {
    fprintf(stderr, "Store address 0x%x and length %lu out of bound\n",
            (unsigned int)addr, (long) size);
    return;
  }
  switch (size) {
    case 1:
      s->storage[addr] = data;
      break;
    case 2:
      *((uint16_t *) (s->storage + addr)) = data;
      break;
    case 4:
      *((uint32_t *) (s->storage + addr)) = data;
      break;
    case 8:
      *((double *) (s->storage + addr)) = *(double *)(&data);
      break;
    default:
      fprintf(stderr, "Unsupported length of storing %lu\n", (long) size);
  }
  if (addr == ADDR_TRIGGER && size == sizeof(int)) {
    // trigger command
    s->repeat_count = (const int) data;
    s->n_meas = 0;
    fprintf(stderr, "Trigger %d time(s) with interval %d and bitmask 0x%x\n",
            s->repeat_count,
            *(int*)(s->storage + ADDR_TRIGGER_INTERVAL),
            *(int*)(s->storage + ADDR_TRIGGER_BITMASK));
    // print the instructions to a file
    FILE* fout = fopen("pulses.txt", "w");
    fprintf(fout, "%d\n", s->repeat_count);
    for (int i = 0; i < s->n_inst; i++) {
      inst_s inst = s->inst_queue[i];
      fprintf(fout, "%d %d %d", inst.time, inst.channel, inst.waveform);
      for (int k = 0; k < 4; k++) fprintf(fout, " %.17g", inst.params[k]);
      fprintf(fout, "\n");
      if (inst.waveform & 0x80) {
        // acquire (i.e. instructions with return values)
        if (inst.res_addr < ADDR_FMR ||
            inst.res_addr + sizeof(int) > ADDR_PLAY) {
          fprintf(stderr, "Destination address 0x%x out of bounds,"
                  " using 0x%lx\n", inst.res_addr, ADDR_PLAY - sizeof(int));
          inst.res_addr = ADDR_PLAY - sizeof(int);
        }
        s->meas_addr[s->n_meas] = inst.res_addr;
        s->meas_addr_iq[s->n_meas++] = inst.res_addr_iq;
      }
    }
    fclose(fout);
    int x = system("cat pulses.txt");
    if (x != 0)
      fprintf(stderr, "Cannot display pulses.txt\n");
    fprintf(stderr, "----\n");
    check_results(s, true);  // make sure to close any previous backend process
    x = system("rm -f exit_code.txt");
    if (x != 0)
      fprintf(stderr, "Cannot remove exit_code.txt\n");
    s->proc = popen(s->command, "w");
    // reset the counter and the queue
    s->abs_time = 0;
    s->n_inst = 0;
  } else if (addr == ADDR_WAIT && size == sizeof(int)) {
    // qwait command
    int dt = (const int) data;
    s->abs_time += dt;
  } else if (addr == ADDR_WAVE_LEN && size == sizeof(int)) {
    // envelope transmission command
    int size = *(int*)(s->storage + ADDR_WAVE_LEN);
    unsigned short channel =
        *(unsigned short*)(s->storage + ADDR_WAVE_CHANNEL);
    uint8_t index = *(uint8_t*)(s->storage + ADDR_WAVE_INDEX);
    store_envelope(s, channel, index, size);
  } else if (addr >= ADDR_PLAY && addr < ADDR_PARAMS &&
              size == sizeof(uint8_t)) {
    // play command
    int channel = (int)(addr - ADDR_PLAY);
    double* params =
        channel < (STORAGE_SIZE - ADDR_PARAMS) / sizeof(double[4])
            ? (double*)(s->storage + ADDR_PARAMS +
                                        channel * sizeof(double[4]))
            : NULL;
    int res_addr = ADDR_FMR + *(int*)(s->storage + ADDR_OFFSET) +
                    channel * sizeof(int);
    int res_addr_iq =
        ADDR_FMR_IQ +
        *(int*)(s->storage + ADDR_OFFSET * sizeof(double[2]) /
                                              sizeof(int)) +
        channel * sizeof(double[2]);
    add_inst(s, s->abs_time, channel, (uint8_t) data,
                 res_addr, res_addr_iq, params);
  }
}

static const MemoryRegionOps yqe_plugin_ops = {
  .read = yqe_plugin_read,
  .write = yqe_plugin_write,
  .endianness = DEVICE_NATIVE_ENDIAN,
  .impl.max_access_size = 8,
};

static void yqe_plugin_instance_init(Object *obj) {
  YQEPluginState *s = YQE_PLUGIN(obj);

  // allocate memory map region
  memory_region_init_io(&s->iomem, obj, &yqe_plugin_ops, s,
                           TYPE_YQE_PLUGIN, 0x100000);
  sysbus_init_mmio(SYS_BUS_DEVICE(obj), &s->iomem);

  // read the command line instruction for the pulse simulator
  FILE* fin = fopen("/yaqcs-arch/simulator/quantum_command.txt", "r");
  if (fgets(s->command, COMMAND_SIZE - 1, fin) == NULL) {
    fprintf(stderr, "Error reading the pulse simulation command!\n");
    fclose(fin);
    exit(1);
  }
  fclose(fin);
  s->abs_time = 0;
  s->n_inst = 0;
  s->proc = NULL;
}

// create a new type to define the info related to our device
static const TypeInfo yqe_plugin_info = {
  .name = TYPE_YQE_PLUGIN,
  .parent = TYPE_SYS_BUS_DEVICE,
  .instance_size = sizeof(YQEPluginState),
  .instance_init = yqe_plugin_instance_init,
};

static void yqe_plugin_register_types(void) {
    type_register_static(&yqe_plugin_info);
}

type_init(yqe_plugin_register_types)

// create the YQE Plugin device.
DeviceState *yqe_plugin_create(hwaddr addr) {
  DeviceState *dev = qdev_new(TYPE_YQE_PLUGIN);
  sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
  sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, addr);
  return dev;
}
